#include "pch.h"

#include "Logger.h"
#include "Shader.h"
#include "Utilities.h"

#pragma region Aliases

using OptShaderId = std::optional<ShaderId>;

using ProgramParameter = GLint;
using OptProgramParameter = std::optional<ProgramParameter>;
using ProgramParameterId = GLenum;

using ShaderParameter = GLint;
using OptShaderParameter = std::optional<ShaderParameter>;
using ShaderParameterId = GLenum;

using UniformLocation = GLint;

#pragma endregion

#pragma region Helper functions

namespace
{

	// Helper functions are declared here and defined immediately below.
	auto AttachShaderToProgram(ShaderId shader, ProgramId program) -> bool;
	auto CompileFragmentShaderFromSource(const Path& fsPath) -> OptShaderId;
	auto CompileShader(ShaderId shader) -> bool;
	auto CompileShaderFromSource(GLenum shaderType, const Path& path) -> OptShaderId;
	auto CompileVertexShaderFromSource(const Path& vsPath) -> OptShaderId;
	auto CreateShader(GLenum shaderType) -> OptShaderId;
	auto DeleteShader(ShaderId shader) -> bool;
	auto DetachShaderFromProgram(ShaderId shader, ProgramId program) -> bool;
	auto GetProgramParameter(ProgramId program, ProgramParameterId parameter) -> OptProgramParameter;
	auto GetShaderParameter(ShaderId shader, ShaderParameterId parameter) -> OptShaderParameter;
	auto ReadFile(const Path& path) -> OptString;
	auto SetSourceCode(ShaderId shader, const String& source) -> bool;

	auto AttachShaderToProgram(ShaderId shader, ProgramId program) -> bool
	{
		glAttachShader(program, shader);
		switch (glGetError())
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "either program or shader is not a value generated by OpenGL.");
			return false;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "program is not a program object, or shader is not a shader object, or shader is already attached to program.");
			return false;
		}

		return true;
	}

	auto CompileFragmentShaderFromSource(const Path& fsPath) -> OptShaderId
	{
		return CompileShaderFromSource(GL_FRAGMENT_SHADER, fsPath);
	}

	auto CompileShader(ShaderId shader) -> bool
	{
		glCompileShader(shader);

		// Check glCompileShader for any errors
		GLenum glError = glGetError();
		switch (glError)
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "shader is not a value generated by OpenGL.");
			return false;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "shader is not a shader object.");
			return false;
		}

		auto optCompileStatus = GetShaderParameter(shader, GL_COMPILE_STATUS);
		if (!optCompileStatus.has_value())
		{
			gLogger.Error(std::format("GetShaderParameter({}, {}) failed.", shader, Viewer::Utilities::GLEnumToString(GL_COMPILE_STATUS)));
			return false;
		}

		if (optCompileStatus.value() == GL_FALSE)
		{
			gLogger.OpenGLError(GL_FALSE, "the last compile operation on shader was unsuccessful.");

			auto optInfoLogLength = GetShaderParameter(shader, GL_INFO_LOG_LENGTH);
			if (!optInfoLogLength.has_value())
			{
				gLogger.Error(std::format("GetShaderParameter({}, {}) failed.", shader, Viewer::Utilities::GLEnumToString(GL_INFO_LOG_LENGTH)));
				return false;
			}

			std::string infoLog(optInfoLogLength.value(), ' ');
			glGetShaderInfoLog(shader, optInfoLogLength.value(), NULL, infoLog.data());
			glError = glGetError();
			switch (glError)
			{
			case GL_INVALID_VALUE:
				gLogger.OpenGLError(GL_INVALID_VALUE, "shader is not a value generated by OpenGL or maxLength is less than 0.");
				return false;
			case GL_INVALID_OPERATION:
				gLogger.OpenGLError(GL_INVALID_VALUE, "shader is not a shader object.");
				return false;
			}

			gLogger.Info(infoLog);
			return false;
		}

		return true;
	}

	auto CompileShaderFromSource(GLenum shaderType, const Path& path) -> OptShaderId
	{
		std::string source;
		if (std::optional<std::string> optSource = ReadFile(path); optSource.has_value())
			source = optSource.value();
		else
		{
			gLogger.Error(std::format("ReadFile({}) failed.", std::filesystem::absolute(path).string()));
			return std::nullopt;
		}

		GLuint shader = 0;
		if (std::optional<GLuint> optId = CreateShader(shaderType); optId.has_value())
			shader = optId.value();
		else
		{
			gLogger.Error(std::format("CreateShader({}) failed.", Viewer::Utilities::GLEnumToString(shaderType)));
			return std::nullopt;
		}

		if (!SetSourceCode(shader, source))
		{
			gLogger.Error(std::format("SetSourceCode({}, {}) failed.", shader, source));
			return std::nullopt;
		}

		if (!CompileShader(shader))
		{
			gLogger.Error(std::format("CompileShader({}) failed.", shader));
			return std::nullopt;
		}

		return shader;
	}

	auto CompileVertexShaderFromSource(const Path& vsPath) -> OptShaderId
	{
		return CompileShaderFromSource(GL_VERTEX_SHADER, vsPath);
	}

	auto CreateShader(GLenum shaderType) -> OptShaderId
	{
		GLuint shader = glCreateShader(shaderType);
		if (shader == 0)
		{
			gLogger.OpenGLError(glGetError(), "Error creating the shader object.");
			return std::nullopt;
		}

		switch (glGetError())
		{
		case GL_INVALID_ENUM:
			gLogger.OpenGLError(GL_INVALID_ENUM, "shaderType is not an accepted value.");
			return std::nullopt;
		}

		return shader;
	}

	auto DeleteShader(ShaderId shader) -> bool
	{
		glDeleteShader(shader);
		switch (glGetError())
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "shader is not a value generated by OpenGL.");
			return false;
		}

		return true;
	}

	auto DetachShaderFromProgram(ShaderId shader, ProgramId program) -> bool
	{
		glDetachShader(program, shader);
		switch (glGetError())
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "either program or shader is a value that was not generated by OpenGL.");
			return false;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "program is not a program object, or shader is not a shader object, or shader is not attached to program.");
			return false;
		}

		return true;
	}

	auto GetProgramParameter(ProgramId program, ProgramParameterId parameter) -> OptProgramParameter
	{
		GLint param;
		glGetProgramiv(program, parameter, &param);
		GLenum glError = glGetError();
		switch (glError)
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "program is not a value generated by OpenGL.");
			return std::nullopt;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "program does not refer to a shader object, or parameter is GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, or GL_GEOMETRY_OUTPUT_TYPE, and program does not contain a geometry shader, or parameter is GL_COMPUTE_WORK_GROUP_SIZE and program does not contain a binary for the compute shader stage.");
			return std::nullopt;
		case GL_INVALID_ENUM:
			gLogger.OpenGLError(GL_INVALID_ENUM, "parameter is not an accepted value.");
			return std::nullopt;
		}

		return param;
	}

	auto GetShaderParameter(ShaderId shader, ShaderParameterId parameter) -> OptShaderParameter
	{
		GLint param;
		glGetShaderiv(shader, parameter, &param);
		GLenum glError = glGetError();
		switch (glError)
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "shader is not a value generated by OpenGL.");
			return std::nullopt;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "shader does not refer to a shader object.");
			return std::nullopt;
		case GL_INVALID_ENUM:
			gLogger.OpenGLError(GL_INVALID_ENUM, "pname is not an accepted value.");
			return std::nullopt;
		}

		return param;
	}

	auto ReadFile(const Path& path) -> OptString
	{
		try
		{
			std::ifstream ifs(path);
			ifs.exceptions(std::ifstream::failbit | std::ifstream::badbit);

			// Read the file in its entirety.
			std::stringstream ss;
			ss << ifs.rdbuf();
			ifs.close();
			std::string source = ss.str();
			return source;
		}
		catch (const std::ifstream::failure& e)
		{
			gLogger.Error(std::format("Error reading {}: {}.", std::filesystem::absolute(path).string(), e.what()));
			return std::nullopt;
		}
	}

	auto SetSourceCode(ShaderId shader, const String& source) -> bool
	{
		const char* sourceCStr = source.c_str();
		glShaderSource(shader, 1, &sourceCStr, NULL);
		GLenum glError = glGetError();
		switch (glError)
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "shader is not a value generated by OpenGL, or count is less than 0.");
			return false;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "shader is not a shader object.");
			return false;
		}

		return true;
	}

}

#pragma endregion

namespace Viewer
{

#pragma region Construction and destruction

	Shader::Shader(const ShaderSources sources)
	{
		std::vector<GLuint> shaders;
		for (const auto& [type, path] : sources)
		{
			switch (type)
			{
			case ShaderType::Fragment:
			{
				if (std::optional<GLuint> optId = CompileFragmentShaderFromSource(path); optId.has_value())
					shaders.push_back(optId.value());
				else
				{
					gLogger.Error(std::format("CompileFragmentShaderFromSource({})", path.string()));
					return;
				}

				break;
			}
			case ShaderType::Vertex:
			{
				if (std::optional<GLuint> optId = CompileVertexShaderFromSource(path); optId.has_value())
					shaders.push_back(optId.value());
				else
				{
					gLogger.Error(std::format("CompileVertexShaderFromSource({})", path.string()));
					return;
				}

				break;
			}
			default:
				gLogger.Error(std::format("Shader type '{}' not supported.", static_cast<size_t>(type)));
				return;
			}
		}

		if (!LinkProgram(shaders))
		{
			gLogger.Error("LinkProgram() failed.");
			return;
		}

		// Cleanup
		for (auto shader : shaders)
		{
			if (!DetachShaderFromProgram(shader, m_Program))
			{
				gLogger.Error(std::format("DetachShaderFromProgram({}, {}) failed.", shader, m_Program));
				return;
			}

			if (!DeleteShader(shader))
			{
				gLogger.Error(std::format("DeleteShader({}) failed.", shader));
				return;
			}
		}

		m_Initialized = true;
	}

	Shader::~Shader()
	{
		glDeleteProgram(m_Program);
		switch (glGetError())
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "program is not a value generated by OpenGL.");
			break;
		}
	}

#pragma endregion

#pragma region Public functions

	auto Shader::SetUniform(const String& name, const Vec4& value) -> bool const
	{
		UniformLocation location = glGetUniformLocation(m_Program, name.c_str());
		if (location == -1)
		{
			gLogger.Error(std::format("{} does not correspond to an active uniform variable in program, or starts with the reserved prefix \"gl_\", or is associated with an atomic counter or a named uniform block.", name));
			return false;
		}
		switch (glGetError())
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "program is not a value generated by OpenGL.");
			return false;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "program is not a program object, or program has not been successfully linked.");
			return false;
		}

		glUniform4f(location, value.x, value.y, value.z, value.w);
		switch (glGetError())
		{
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "there is no current program object, or the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command, or one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these, or one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these, or one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these, or location is an invalid uniform location for the current program object and location is not equal to -1, or count is greater than 1 and the indicated uniform variable is not an array variable, or a sampler is loaded using a command other than glUniform1i and glUniform1iv.");
			return false;
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "count is less than 0.");
			return false;
		}

		return true;
	}

	auto Shader::Use() -> bool const
	{
		glUseProgram(m_Program);
		switch (glGetError())
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "program is neither 0 nor a value generated by OpenGL.");
			return false;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "program is not a program object, or program could not be made part of current state, or transform feedback mode is active.");
			return false;
		}

		return true;
	}

#pragma endregion

#pragma region Private functions

	auto Shader::LinkProgram(const ShaderIds& shaders) -> bool
	{
		m_Program = glCreateProgram();
		if (m_Program == 0)
		{
			gLogger.Error("An error occurred creating the program object.");
			return false;
		}

		for (const auto& shader : shaders)
		{
			if (!AttachShaderToProgram(shader, m_Program))
			{
				gLogger.Error(std::format("AttachShaderToProgram({}, {}) failed.", shader, m_Program));
				return false;
			}
		}

		glLinkProgram(m_Program);
		switch (glGetError())
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "program is not a value generated by OpenGL.");
			return false;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "program is not a program object, or program is the currently active program object and transform feedback mode is active.");
			return false;
		}

		auto optLinkStatus = GetProgramParameter(m_Program, GL_LINK_STATUS);
		if (!optLinkStatus.has_value())
		{
			gLogger.Error(std::format("GetProgramParameter({}, {}) failed.", m_Program, Viewer::Utilities::GLEnumToString(GL_LINK_STATUS)));
			return false;
		}

		if (optLinkStatus.value() == GL_FALSE)
		{
			gLogger.OpenGLError(GL_FALSE, "the last link operation on program was unsuccessful.");

			auto optInfoLogLength = GetShaderParameter(m_Program, GL_INFO_LOG_LENGTH);
			if (!optInfoLogLength.has_value())
			{
				gLogger.Error(std::format("GetShaderParameter({}, {}) failed.", m_Program, GL_INFO_LOG_LENGTH));
				return false;
			}

			std::string infoLog(optInfoLogLength.value(), ' ');
			glGetProgramInfoLog(m_Program, optInfoLogLength.value(), NULL, infoLog.data());
			switch (glGetError())
			{
			case GL_INVALID_VALUE:
				gLogger.OpenGLError(GL_INVALID_VALUE, "program is not a value generated by OpenGL or maxLength is less than 0.");
				return false;
			case GL_INVALID_OPERATION:
				gLogger.OpenGLError(GL_INVALID_VALUE, "program is not a program object.");
				return false;
			}

			gLogger.Info(infoLog);
			return false;
		}

		return true;
	}

#pragma endregion

}
