#include "pch.h"

#include "Logger.h"
#include "Shader.h"
#include "Utilities.h"

namespace
{

	// Helper functions are declared here and defined immediately below.
	bool AttachShaderToProgram(GLuint shader, GLuint program);
	bool CompileShader(GLuint shader);
	bool DeleteShader(GLuint shader);
	bool DetachShaderFromProgram(GLuint shader, GLuint program);
	std::optional<GLint> GetProgramParameter(GLuint program, GLenum parameter);
	std::optional<GLint> GetShaderParameter(GLuint shader, GLenum parameter);
	std::optional<std::string> ReadFile(const std::filesystem::path& path);

	bool AttachShaderToProgram(GLuint shader, GLuint program)
	{
		glAttachShader(program, shader);
		switch (glGetError())
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "either program or shader is not a value generated by OpenGL.");
			return false;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "program is not a program object, or shader is not a shader object, or shader is already attached to program.");
			return false;
		}

		return true;
	}

	bool CompileShader(GLuint shader)
	{
		glCompileShader(shader);

		// Check glCompileShader for any errors
		GLenum glError = glGetError();
		switch (glError)
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "shader is not a value generated by OpenGL.");
			return false;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "shader is not a shader object.");
			return false;
		}

		auto optCompileStatus = GetShaderParameter(shader, GL_COMPILE_STATUS);
		if (!optCompileStatus.has_value())
			return false;

		if (optCompileStatus.value() == GL_FALSE)
		{
			gLogger.OpenGLError(GL_FALSE, "the last compile operation on shader was unsuccessful.");

			auto optInfoLogLength = GetShaderParameter(shader, GL_INFO_LOG_LENGTH);
			if (!optInfoLogLength.has_value())
				return false;

			std::string infoLog(optInfoLogLength.value(), ' ');
			glGetShaderInfoLog(shader, optInfoLogLength.value(), NULL, infoLog.data());
			glError = glGetError();
			switch (glError)
			{
			case GL_INVALID_VALUE:
				gLogger.OpenGLError(GL_INVALID_VALUE, "shader is not a value generated by OpenGL or maxLength is less than 0.");
				return false;
			case GL_INVALID_OPERATION:
				gLogger.OpenGLError(GL_INVALID_VALUE, "shader is not a shader object.");
				return false;
			}

			gLogger.Info(infoLog);
			return false;
		}

		return true;
	}

	bool DeleteShader(GLuint shader)
	{
		glDeleteShader(shader);
		switch (glGetError())
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "shader is not a value generated by OpenGL.");
			return false;
		}

		return true;
	}

	bool DetachShaderFromProgram(GLuint shader, GLuint program)
	{
		glDetachShader(program, shader);
		switch (glGetError())
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "either program or shader is a value that was not generated by OpenGL.");
			return false;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "program is not a program object, or shader is not a shader object, or shader is not attached to program.");
			return false;
		}

		return true;
	}

	std::optional<GLint> GetProgramParameter(GLuint program, GLenum parameter)
	{
		GLint param;
		glGetProgramiv(program, parameter, &param);
		GLenum glError = glGetError();
		switch (glError)
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "program is not a value generated by OpenGL.");
			return std::nullopt;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "program does not refer to a shader object, or parameter is GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, or GL_GEOMETRY_OUTPUT_TYPE, and program does not contain a geometry shader, or parameter is GL_COMPUTE_WORK_GROUP_SIZE and program does not contain a binary for the compute shader stage.");
			return std::nullopt;
		case GL_INVALID_ENUM:
			gLogger.OpenGLError(GL_INVALID_ENUM, "parameter is not an accepted value.");
			return std::nullopt;
		}

		return param;
	}

	std::optional<GLint> GetShaderParameter(GLuint shader, GLenum parameter)
	{
		GLint param;
		glGetShaderiv(shader, parameter, &param);
		GLenum glError = glGetError();
		switch (glError)
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "shader is not a value generated by OpenGL.");
			return std::nullopt;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "shader does not refer to a shader object.");
			return std::nullopt;
		case GL_INVALID_ENUM:
			gLogger.OpenGLError(GL_INVALID_ENUM, "pname is not an accepted value.");
			return std::nullopt;
		}

		return param;
	}

	std::optional<std::string> ReadFile(const std::filesystem::path& path)
	{
		try
		{
			std::ifstream ifs(path);
			ifs.exceptions(std::ifstream::failbit | std::ifstream::badbit);

			// Read the file in its entirety.
			std::stringstream ss;
			ss << ifs.rdbuf();
			ifs.close();
			std::string source = ss.str();
			return source;
		}
		catch (const std::ifstream::failure& e)
		{
			gLogger.Error(std::format("Error reading {}: {}.", std::filesystem::absolute(path).string(), e.what()));
			return std::nullopt;
		}
	}

}

namespace Viewer
{

	Shader::~Shader()
	{
		glDeleteProgram(m_Program);
		switch (glGetError())
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "program is not a value generated by OpenGL.");
			break;
		}
	}

	bool Shader::CompileShaderFromSource(GLenum shaderType, const std::filesystem::path& path)
	{
		GLuint* shader = GetShaderData(shaderType);
		if (!shader)
		{
			gLogger.Error("GetShaderData failed.");
			return false;
		}

		std::string source;
		if (std::optional<std::string> optSource = ReadFile(path); optSource.has_value())
			source = optSource.value();
		else
		{
			gLogger.Error(std::format("ReadFile({}) failed.", std::filesystem::absolute(path).string()));
			return false;
		}

		if (std::optional<GLuint> optId = CreateShader(shaderType); optId.has_value())
			*shader = optId.value();
		else
		{
			gLogger.Error(std::format("CreateShader({}) failed.", Utilities::GLEnumToString(shaderType)));
			return false;
		}

		if (!SetSourceCode(*shader, source))
		{
			gLogger.Error(std::format("SetSourceCode({}, {}) failed.", *shader, source));
			return false;
		}

		if (!CompileShader(*shader))
		{
			gLogger.Error(std::format("CompileShader({}) failed.", *shader));
			return false;
		}

		return true;
	}

	std::optional<GLuint> Shader::CreateShader(GLenum shaderType)
	{
		GLuint shader = glCreateShader(shaderType);
		if (shader == 0)
		{
			gLogger.OpenGLError(glGetError(), "Error creating the shader object.");
			return std::nullopt;
		}

		switch (glGetError())
		{
		case GL_INVALID_ENUM:
			gLogger.OpenGLError(GL_INVALID_ENUM, "shaderType is not an accepted value.");
			return std::nullopt;
		}

		return shader;
	}

	GLuint* Shader::GetShaderData(GLenum shaderType)
	{
		GLuint* shader = nullptr;
		switch (shaderType)
		{
		case GL_FRAGMENT_SHADER:
			shader = &m_VertexShader;
			break;
		case GL_VERTEX_SHADER:
			shader = &m_FragmentShader;
			break;
		default:
			gLogger.Error(std::format("Shader class contains no data for a shader of type {}.", Utilities::GLEnumToString(shaderType)));
			break;
		}

		return shader;
	};

	bool Shader::SetSourceCode(int shader, const std::string& source)
	{
		const char* sourceCStr = source.c_str();
		glShaderSource(shader, 1, &sourceCStr, NULL);
		GLenum glError = glGetError();
		switch (glError)
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "shader is not a value generated by OpenGL, or count is less than 0.");
			return false;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "shader is not a shader object.");
			return false;
		}

		return true;
	}

	bool Shader::CompileFragmentShaderFromSource(const std::filesystem::path& fsPath)
	{
		return CompileShaderFromSource(GL_FRAGMENT_SHADER, fsPath);
	}

	bool Shader::CompileVertexShaderFromSource(const std::filesystem::path& vsPath)
	{
		return CompileShaderFromSource(GL_VERTEX_SHADER, vsPath);
	}

	bool Shader::LinkProgram()
	{
		m_Program = glCreateProgram();
		if (m_Program == 0)
		{
			gLogger.Error("An error occurred creating the program object.");
			return false;
		}

		if (!AttachShaderToProgram(m_VertexShader, m_Program))
		{
			gLogger.Error(std::format("AttachShaderToProgram({}, {}) failed.", m_VertexShader, m_Program));
			return false;
		}

		if (!AttachShaderToProgram(m_FragmentShader, m_Program))
		{
			gLogger.Error(std::format("AttachShaderToProgram({}, {}) failed.", m_VertexShader, m_Program));
			return false;
		}

		glLinkProgram(m_Program);
		switch (glGetError())
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "program is not a value generated by OpenGL.");
			return false;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "program is not a program object, or program is the currently active program object and transform feedback mode is active.");
			return false;
		}

		auto optLinkStatus = GetProgramParameter(m_Program, GL_LINK_STATUS);
		if (!optLinkStatus.has_value())
			return false;

		if (optLinkStatus.value() == GL_FALSE)
		{
			gLogger.OpenGLError(GL_FALSE, "the last link operation on program was unsuccessful.");

			auto optInfoLogLength = GetShaderParameter(m_Program, GL_INFO_LOG_LENGTH);
			if (!optInfoLogLength.has_value())
			{
				gLogger.Error(std::format("GetShaderParameter({}, {}) failed.", m_Program, GL_INFO_LOG_LENGTH));
				return false;
			}

			std::string infoLog(optInfoLogLength.value(), ' ');
			glGetProgramInfoLog(m_Program, optInfoLogLength.value(), NULL, infoLog.data());
			switch (glGetError())
			{
			case GL_INVALID_VALUE:
				gLogger.OpenGLError(GL_INVALID_VALUE, "program is not a value generated by OpenGL or maxLength is less than 0.");
				return false;
			case GL_INVALID_OPERATION:
				gLogger.OpenGLError(GL_INVALID_VALUE, "program is not a program object.");
				return false;
			}

			gLogger.Info(infoLog);
			return false;
		}

		if (!DetachShaderFromProgram(m_VertexShader, m_Program))
		{
			gLogger.Error(std::format("DetachShaderFromProgram({}, {}) failed.", m_VertexShader, m_Program));
			return false;
		}

		if (!DeleteShader(m_VertexShader))
		{
			gLogger.Error(std::format("DeleteShader({}) failed.", m_VertexShader));
			return false;
		}

		if (!DetachShaderFromProgram(m_FragmentShader, m_Program))
		{
			gLogger.Error(std::format("DetachShaderFromProgram({}, {}) failed.", m_FragmentShader, m_Program));
			return false;
		}

		if (!DeleteShader(m_FragmentShader))
		{
			gLogger.Error(std::format("DeleteShader({}) failed.", m_FragmentShader));
			return false;
		}

		return true;
	}

	bool Shader::Use() const
	{
		glUseProgram(m_Program);
		switch (glGetError())
		{
		case GL_INVALID_VALUE:
			gLogger.OpenGLError(GL_INVALID_VALUE, "program is neither 0 nor a value generated by OpenGL.");
			return false;
		case GL_INVALID_OPERATION:
			gLogger.OpenGLError(GL_INVALID_OPERATION, "program is not a program object, or program could not be made part of current state, or transform feedback mode is active.");
			return false;
		}

		return true;
	}

}
